apiVersion: tekton.dev/v1
kind: Task
metadata:
  labels:
    app.kubernetes.io/version: "0.3"
    build.appstudio.redhat.com/build_type: "docker"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: "appstudio, hacbs"
  name: clamav-scan
spec:
  description: >-
    Scans the content of container images for viruses, malware, and other security threats using ClamAV.
    This version uses clamdscan with the clamd daemon for improved performance through database caching.
  params:
    - description: Image digest to scan.
      name: image-digest
      type: string
    - description: Image URL.
      name: image-url
      type: string
    - description: Number of threads to run in clamdscan parallel. Should be <= 8.
      name: scan-threads
      type: string
      default: "1"
    - description: Maximum number of scan threads allowed.
      name: max-scan-threads
      type: string
      default: "8"
    - description: Configmap name holding the certificate bundle file.
      name: ca-trust-config-map-name
      type: string
      default: trusted-ca
    - description: The name of the key containing the certificate bundle file.
      name: ca-trust-config-map-key
      type: string
      default: ca-bundle.crt
  results:
    - description: Images processed in the task.
      name: IMAGES_PROCESSED
    - description: Tekton task test output.
      name: TEST_OUTPUT
  steps:
    - env:
        - name: IMAGE_URL
          value: $(params.image-url)
        - name: IMAGE_DIGEST
          value: $(params.image-digest)
        - name: SCAN_THREADS
          value: $(params.scan-threads)
        - name: MAX_SCAN_THREADS
          value: $(params.max-scan-threads)
      image: quay.io/konflux-ci/clamav-db:latest
      # per https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting
      # the cluster will set imagePullPolicy to IfNotPresent
      # also per direction from Ralph Bean, we want to use image digest based tags to use a cue to automation like dependabot or renovatebot to periodically submit pull requests that update the digest as new images are released.
      workingDir: /work
      computeResources:
        limits:
          memory: 16Gi
          cpu: 2
        requests:
          memory: 4Gi
          cpu: 200m
      script: |
        #!/usr/bin/env bash

        # Parse and validate scan threads parameter
        threads=${SCAN_THREADS:-1}
        if ! [[ "$threads" =~ ^[0-9]+$ ]] || [ "$threads" -lt 1 ]; then
          echo "ERROR: SCAN_THREADS must be a positive integer, got: '$threads'"
          exit 1
        fi

        MAX_SCAN_THREADS=${MAX_SCAN_THREADS:-8}
        if ! [[ "$MAX_SCAN_THREADS" =~ ^[0-9]+$ ]] || [ "$MAX_SCAN_THREADS" -lt 1 ]; then
          echo "ERROR: MAX_SCAN_THREADS must be a positive integer, got: '$MAX_SCAN_THREADS'"
          exit 1
        fi

        # warning if SCAN_THREADS is greater than visible CPUs
        if [ "$threads" -gt "$(nproc)" ]; then
          echo "[WARN] SCAN_THREADS ($threads) exceeds visible CPUs ($(nproc)) — performance may degrade."
        fi

        # Cap threads to MAX_THREADS
        if [ "$threads" -gt "$MAX_SCAN_THREADS" ]; then
          echo "SCAN_THREADS ($threads) exceeds MAX_SCAN_THREADS ($MAX_SCAN_THREADS) — capping threads to: $MAX_SCAN_THREADS"
          threads="$MAX_SCAN_THREADS"
        fi

        set -euo pipefail
        . /utils.sh
        trap 'handle_error $(results.TEST_OUTPUT.path)' EXIT

        # Check if clamd is already running by looking for common socket locations
        CLAMD_SOCKET=""
        for socket in /var/run/clamd.scan/clamd.sock /var/run/clamd.sock /tmp/clamd.sock /var/lib/clamav/clamd.sock; do
          if [ -S "$socket" ]; then
            CLAMD_SOCKET="$socket"
            echo "Found existing clamd socket at: $CLAMD_SOCKET"
            break
          fi
        done

        # Test if clamd is responsive
        if [ -n "$CLAMD_SOCKET" ]; then
          if echo "PING" | nc -U "$CLAMD_SOCKET" | grep -q "PONG"; then
            echo "clamd daemon is already running and responsive"
            USE_EXISTING_CLAMD=true
          else
            echo "Found socket but clamd not responsive, will start our own"
            USE_EXISTING_CLAMD=false
          fi
        else
          echo "No existing clamd socket found, will start our own"
          USE_EXISTING_CLAMD=false
        fi

        # Start our own clamd if needed
        if [ "$USE_EXISTING_CLAMD" = "false" ]; then
          echo "Starting clamd daemon for improved performance..."
          
          # Find the database directory
          DB_DIR=""
          for dir in /var/lib/clamav /usr/local/share/clamav /opt/clamav/share/clamav; do
            if [ -d "$dir" ] && [ -n "$(ls -A "$dir" 2>/dev/null)" ]; then
              DB_DIR="$dir"
              break
            fi
          done
          
          if [ -z "$DB_DIR" ]; then
            echo "ERROR: Could not find ClamAV database directory"
            exit 1
          fi
          
          echo "Using database directory: $DB_DIR"

          # Create clamd configuration
          mkdir -p /tmp/clamd
          CLAMD_SOCKET="/tmp/clamd.sock"
          {
            echo "LocalSocket $CLAMD_SOCKET"
            echo "DatabaseDirectory $DB_DIR"
            echo "LogFile /tmp/clamd.log"
            echo "LogVerbose yes"
            echo "PidFile /tmp/clamd.pid"
            echo "User root"
            echo "MaxScanSize 4095M"
            echo "MaxFileSize 2000M"
            echo "MaxScanTime 0"
            echo "MaxFiles 0"
            echo "MaxRecursion 1000"
            echo "MaxDirectoryRecursion 20000"
            echo "MaxEmbeddedPE 4095M"
            echo "MaxHTMLNormalize 10M"
            echo "MaxHTMLNoTags 4095M"
            echo "MaxScriptNormalize 5M"
            echo "MaxZipTypeRcg 4095M"
            echo "MaxPartitions 50000"
            echo "MaxIconsPE 100000"
            echo "MaxRecHWP3 20000"
            echo "PCREMatchLimit 100000000"
            echo "PCRERecMatchLimit 2000000"
            echo "PCREMaxFileSize 4095M"
          } > /tmp/clamd.conf

          clamd -c /tmp/clamd.conf &
          CLAMD_PID=$!
          
          # Wait for clamd to be ready
          echo "Waiting for clamd daemon to be ready..."
          timeout=60
          while ! test -S "$CLAMD_SOCKET"; do
            if [ $timeout -le 0 ]; then
              echo "ERROR: clamd daemon failed to start within 60 seconds"
              if [ -f /tmp/clamd.log ]; then
                echo "=== clamd.log ==="
                cat /tmp/clamd.log
              fi
              exit 1
            fi
            sleep 1
            timeout=$((timeout - 1))
          done
          
          # Test connection
          if ! echo "PING" | nc -U "$CLAMD_SOCKET" | grep -q "PONG"; then
            echo "ERROR: Unable to connect to clamd daemon"
            if [ -f /tmp/clamd.log ]; then
              echo "=== clamd.log ==="
              cat /tmp/clamd.log
            fi
            exit 1
          fi
          
          echo "clamd daemon is ready"
          
          # Ensure clamd is stopped on exit
          trap 'kill $CLAMD_PID 2>/dev/null || true; handle_error $(results.TEST_OUTPUT.path)' EXIT
        fi

        imagewithouttag=$(echo $IMAGE_URL | sed "s/\(.*\):.*/\1/" | tr -d '\n')

        # strip new-line escape symbol from parameter and save it to variable
        imageanddigest=$(echo $imagewithouttag@$IMAGE_DIGEST)

        # check if image is attestation one, skip the clamav scan in such case
        if [[ $imageanddigest == *.att ]]
        then
            echo "$imageanddigest is an attestation image. Skipping ClamAV scan."
            exit 0
        fi

        images_processed_template='{"image": {"pullspec": "'"$IMAGE_URL"'", "digests": [%s]}}'
        digests_processed=()
        mkdir logs
        mkdir content
        cd content
        echo "Extracting image(s)."

        # Get the arch and image manifests by inspecting the image. This is mainly for identifying image indexes
        image_manifests=$(get_image_manifests -i "${imageanddigest}")
        if [ -n "$image_manifests" ]; then
          while read -r arch arch_sha; do
            destination=$(echo content-$arch)
            mkdir -p "$destination"
            arch_imageanddigest=$(echo $imagewithouttag@$arch_sha)

            echo "Running \"oc image extract\" on image of arch $arch"
            retry oc image extract --registry-config ~/.docker/config.json "$arch_imageanddigest" --path="/:${destination}" --filter-by-os="linux/${arch}"
            if [ $? -ne 0 ]; then
              echo "Unable to extract image for arch $arch. Skipping ClamAV scan!"
              exit 0
            fi

            # Get database version from clamdscan
            if [ "$USE_EXISTING_CLAMD" = "true" ]; then
              # Use existing clamd, try without config file first
              if clamdscan --version >/dev/null 2>&1; then
                db_version=$(clamdscan --version | sed 's|.*/\(.*\)/.*|\1|')
              else
                # Fallback to clamscan for version
                db_version=$(clamscan --version | sed 's|.*/\(.*\)/.*|\1|')
              fi
            else
              # Use our custom config
              db_version=$(clamdscan --config-file=/tmp/clamd.conf --version | sed 's|.*/\(.*\)/.*|\1|')
            fi

            if [[ "$threads" -eq 1 ]]; then
              # single-threaded mode
              echo "Single-threaded mode detected."
              echo "Scanning image for arch $arch using clamdscan. This operation may take a while."
              
              if [ "$USE_EXISTING_CLAMD" = "true" ]; then
                # Use existing clamd (try default socket)
                clamdscan --infected "${destination}" \
                  | tee "/work/logs/clamscan-result-1-$arch.log" || true
              else
                # Use our clamd with custom config
                clamdscan --config-file=/tmp/clamd.conf --infected "${destination}" \
                  | tee "/work/logs/clamscan-result-1-$arch.log" || true
              fi
            else
              echo "Multi-threaded mode detected ($threads threads)."

              # Step 1: Generate complete manifest of all file paths in the destination and their sizes
              echo "Generating sanitized file list..."
              find "$destination" -type f -print0 | while IFS= read -r -d '' file; do
                  size=$(stat -c "%s" "$file")
                  printf "%s\t%s\n" "$size" "$file"
              done >"$HOME/files_manifest.tsv"

              # Step 2: Sort the list by size descending
              echo "Sorting files by size (descending)..."
              sort -nr "$HOME/files_manifest.tsv" >"$HOME/files_manifest_sorted.tsv"

              # Step 3: create empty bucket files based on scan-threads
              for i in $(seq 0 $((threads - 1))); do
                  : >"$HOME/file_bucket_$i.txt"
              done

              # Step 4: Distribute files to buckets (round-robin)
              echo "Distributing files into $threads buckets..."
              i=0
              while IFS=$'\t' read -r size path; do
                  bucket=$((i % threads))
                  echo "$path" >>"$HOME/file_bucket_$bucket.txt"
                  ((i = i + 1))
              done <"$HOME/files_manifest_sorted.tsv"

              # Step 5: Launch clamdscan processes in parallel
              echo "Launching clamdscan processes..."
              for i in $(seq 0 $((threads - 1))); do
                  LOGFILE="$HOME/logs/clamscan-result-$i-$arch.log"
                  BUCKET_FILE="$HOME/file_bucket_$i.txt"

                  echo "Starting clamdscan on bucket $i..."

                  if [ "$USE_EXISTING_CLAMD" = "true" ]; then
                    # Use existing clamd
                    clamdscan --infected --file-list="$BUCKET_FILE" \
                        | tee "$LOGFILE" || true &
                  else
                    # Use our clamd with custom config
                    clamdscan --config-file=/tmp/clamd.conf --infected --file-list="$BUCKET_FILE" \
                        | tee "$LOGFILE" || true &
                  fi
              done

              echo "Waiting for all clamdscan processes to finish..."
              wait
              echo "All scans completed. Logs are in: $HOME"
            fi

            digests_processed+=("\"$arch_sha\"")

            for logfile in /work/logs/clamscan-result-*-"$arch".log; do
              [ -e "$logfile" ] || continue

              echo "Executed-on: Scan was executed on clamdscan version - Database version: $db_version" | tee -a "$logfile"

              echo "Running EC on: $logfile"
              bucket_id=$(basename "$logfile" | sed -E 's/clamscan-result-([0-9]+)-.*\.log/\1/')
              json_input="/work/logs/clamsav-result-$bucket_id-$arch.json"
              json_output="/work/logs/clamscan-ec-test-$bucket_id-$arch.json"

              # Convert log to JSON format for EC
              jq -Rs '{ output: . }' "$logfile" > "$json_input"

              # Run EC (json)
              EC_EXPERIMENTAL=1 ec test \
                --namespace required_checks \
                --policy /project/clamav/virus-check.rego \
                -o json \
                "$json_input" || true

              # workaround: due to a bug in ec-cli, we cannot generate json and appstudio output at the same time, running it again
              EC_EXPERIMENTAL=1 ec test \
                --namespace required_checks \
                --policy /project/clamav/virus-check.rego \
                -o appstudio \
                "$json_input" | tee "$json_output" || true

              cat "$json_output"
            done
          done < <(echo "$image_manifests" | jq -r 'to_entries[] | "\(.key) \(.value)"')
        else
          echo "Failed to get image manifests from image \"$imageanddigest\""
          note="Task $(context.task.name) failed: Failed to get image manifests from image \"$imageanddigest\". For details, check Tekton task log."
          ERROR_OUTPUT=$(make_result_json -r "ERROR" -t "$note")
          echo "${ERROR_OUTPUT}" | tee "$(results.TEST_OUTPUT.path)"
          exit 0
        fi

        jq -s -rce '
          reduce .[] as $item ({"timestamp":"0","namespace":"","successes":0,"failures":0,"warnings":0,"result":"","note":""};
            {
            "timestamp" : (if .timestamp < $item.timestamp then $item.timestamp else .timestamp end),
            "namespace" : $item.namespace,
            "successes" : (.successes + $item.successes),
            "failures" : (.failures + $item.failures),
            "warnings" : (.warnings + $item.warnings),
            "result" : (if .result == "" or ($item.result == "SKIPPED" and .result == "SUCCESS") or ($item.result == "WARNING" and (.result == "SUCCESS" or .result == "SKIPPED")) or ($item.result == "FAILURE" and .result != "ERROR") or $item.result == "ERROR" then $item.result else .result end),
            "note" : (if .result == "" or ($item.result == "SKIPPED" and .result == "SUCCESS") or ($item.result == "WARNING" and (.result == "SUCCESS" or .result == "SKIPPED")) or ($item.result == "FAILURE" and .result != "ERROR") or $item.result == "ERROR" then $item.note else .note end)
            })' /work/logs/clamscan-ec-test-*.json | tee $(results.TEST_OUTPUT.path)

        # If the image is an Image Index, also add the Image Index digest to the list.
        if [[ "${digests_processed[*]}" != *"$IMAGE_DIGEST"* ]]; then
          digests_processed+=("\"$IMAGE_DIGEST\"")
        fi

        digests_processed_string=$(IFS=,; echo "${digests_processed[*]}")
        echo "${images_processed_template/\[%s]/[$digests_processed_string]}" | tee $(results.IMAGES_PROCESSED.path)
      volumeMounts:
        - mountPath: /work
          name: work
        - name: trusted-ca
          mountPath: /etc/pki/tls/certs/ca-custom-bundle.crt
          subPath: ca-bundle.crt
          readOnly: true
    - name: upload
      image: quay.io/konflux-ci/oras:latest@sha256:1beeecce012c99794568f74265c065839f9703d28306a8430b667f639343a98b
      computeResources:
        limits:
          memory: 512Mi
        requests:
          memory: 256Mi
          cpu: 100m
      env:
        - name: IMAGE_URL
          value: $(params.image-url)
        - name: IMAGE_DIGEST
          value: $(params.image-digest)
      workingDir: /work
      script: |
        #!/usr/bin/env bash

        cd logs

        for UPLOAD_FILE in clamscan-result*.log; do
          [ -e "$UPLOAD_FILE" ] || continue
          MEDIA_TYPE=text/vnd.clamav
          args+=("${UPLOAD_FILE}:${MEDIA_TYPE}")
        done
        for UPLOAD_FILE in clamscan-ec-test*.json; do
          [ -e "$UPLOAD_FILE" ] || continue
          MEDIA_TYPE=application/vnd.konflux.test_output+json
          args+=("${UPLOAD_FILE}:${MEDIA_TYPE}")
        done

        if [ -z "${args[*]}" ]; then
          echo "No files found. Skipping upload."
          exit 0;
        fi

        echo "Selecting auth"
        select-oci-auth $IMAGE_URL > $HOME/auth.json
        echo "Attaching to ${IMAGE_URL}"
        retry oras attach --no-tty --registry-config "$HOME/auth.json" --artifact-type application/vnd.clamav "${IMAGE_URL}" "${args[@]}"
      volumeMounts:
        - mountPath: /work
          name: work
  volumes:
    - name: work
      emptyDir: {}
    - name: trusted-ca
      configMap:
        name: $(params.ca-trust-config-map-name)
        items:
          - key: $(params.ca-trust-config-map-key)
            path: ca-bundle.crt
        optional: true 