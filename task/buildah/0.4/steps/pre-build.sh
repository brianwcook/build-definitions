#!/bin/bash
set -euo pipefail

# Pre-build step: Calculate tree hash and check for reusable artifacts
# This step runs before the main build step to determine if we can reuse an existing artifact

echo "[$(date --utc -Ins)] Pre-build: Calculate tree hash and check for reusable artifacts"

# Check if artifact reuse is disabled
if [ "${REUSE_ARTIFACTS:-true}" = "false" ]; then
  echo "Artifact reuse is disabled (REUSE_ARTIFACTS=false), proceeding with fresh build"
  echo "false" > "$(workspaces.source.path)/artifact-reused"
  echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
  echo "[$(date --utc -Ins)] Pre-build complete (artifact reuse disabled)"
  exit 0
fi

# Check if EVENT_TYPE parameter is available (required for proper artifact reuse)
if [ -z "${EVENT_TYPE:-}" ]; then
  echo "WARNING: EVENT_TYPE parameter is not set. This is required for proper artifact reuse functionality."
  echo "To fix this, add the event_type parameter to your PipelineRun:"
  echo "  params:"
  echo "    - name: event_type"
  echo "      value: \$(context.pipelineRun.annotations['pipelinesascode.tekton.dev/event-type'] || 'push')"
  echo "Proceeding with build due to missing EVENT_TYPE parameter"
  echo "false" > "$(workspaces.source.path)/artifact-reused"
  echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
  echo "[$(date --utc -Ins)] Pre-build complete (missing EVENT_TYPE)"
  exit 0
fi

# Load parameter defaults from JSON file (generated by Makefile)
PARAM_DEFAULTS="{}"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "$SCRIPT_DIR/param-defaults.json" ]; then
  PARAM_DEFAULTS=$(cat "$SCRIPT_DIR/param-defaults.json")
  echo "Loaded parameter defaults from $SCRIPT_DIR/param-defaults.json"
else
  echo "Warning: param-defaults.json not found in $SCRIPT_DIR, using empty defaults"
fi

# EVENT_TYPE parameter is available for pipeline type detection
echo "DEBUG: Pre-build step - EVENT_TYPE=${EVENT_TYPE:-not set}"
echo "DEBUG: Pre-build step - IMAGE=${IMAGE:-not set}"
echo "DEBUG: Pre-build step - COMMIT_SHA=${COMMIT_SHA:-not set}"

# Calculate tree hash from source code
if [ -n "${COMMIT_SHA:-}" ]; then
  echo "Calculating tree hash for commit ${COMMIT_SHA}..."
  TREE_HASH=$(git -C "$(workspaces.source.path)/source" show -s --format="%T" "${COMMIT_SHA}")
  echo "Tree hash for commit ${COMMIT_SHA}: ${TREE_HASH}"
else
  echo "No commit SHA provided, calculating tree hash from current source..."
  TREE_HASH=$(git -C "$(workspaces.source.path)/source" show -s --format="%T" HEAD)
  echo "Tree hash from current source: ${TREE_HASH}"
fi



# Store tree hash for use in subsequent steps
echo "${TREE_HASH}" > "$(workspaces.source.path)/tree-hash"

# Emit the GIT_TREE_HASH result
echo -n "${TREE_HASH}" | tee "$(results.GIT_TREE_HASH.path)"

# Check for reusable artifacts
echo "Checking for reusable artifacts with tree hash: ${TREE_HASH}"

# Parse exclusion list
EXCLUSION_PARAMS=()
if [ -n "${REUSE_COMPARISON_EXCLUSIONS:-}" ]; then
  while IFS= read -r line; do
    if [ -n "$line" ]; then
      # Remove leading dash and spaces from YAML list format
      cleaned_line="${line#- }"
      cleaned_line="${cleaned_line#-}"
      cleaned_line="${cleaned_line#"${cleaned_line%%[! ]*}"}"
      if [ -n "$cleaned_line" ]; then
        EXCLUSION_PARAMS+=("$cleaned_line")
      fi
    fi
  done <<< "$REUSE_COMPARISON_EXCLUSIONS"
fi

echo "Parameters to exclude from comparison: ${EXCLUSION_PARAMS[*]}"

# Check for existing tree hash tag
# Include platform in tree tag if PLATFORM parameter is provided
# Note: PLATFORM is only available in remote tasks (buildah-remote, buildah-remote-oci-ta)
if [ -n "${PLATFORM:-}" ]; then
  echo "Running in matrix context with platform: ${PLATFORM}, including platform in tree tag"
  # Sanitize platform string for use in Docker tags (replace problematic characters with '-')
  # Docker tags can only contain: a-z, A-Z, 0-9, _, ., -
  SANITIZED_PLATFORM="${PLATFORM//[^a-zA-Z0-9_.-]/-}"
  echo "Sanitized platform for tree tag: ${SANITIZED_PLATFORM}"
  TREE_TAG="tree-${TREE_HASH}-${SANITIZED_PLATFORM}"
else
  TREE_TAG="tree-${TREE_HASH}"
fi
echo "Checking for tree tag: ${TREE_TAG} on ${IMAGE%:*} for architecture: $(uname -m)"

# Check if the tree hash tag exists using skopeo inspect (more efficient than list-tags)
if skopeo inspect "docker://${IMAGE%:*}:${TREE_TAG}" >/dev/null 2>&1; then
  echo "Found tree hash tag: ${TREE_TAG}"
  SELECTED_CANDIDATE="$TREE_TAG"

  # Get the digest for the tree hash tag
  TREE_TAG_DIGEST=$(skopeo inspect "docker://${IMAGE%:*}:${SELECTED_CANDIDATE}" | jq -r '.Digest')
  echo "Tree hash tag digest: $TREE_TAG_DIGEST"

  # Dynamically fetch the signing key from the cluster
  echo "Fetching signing key from cluster..."
  echo "Running: kubectl -n openshift-pipelines get secret public-key -o json"
  
  # First, let's see if the secret exists and what it contains
  SECRET_OUTPUT=$(kubectl -n openshift-pipelines get secret public-key -o json 2>&1)
  SECRET_EXIT_CODE=$?
  
  if [ $SECRET_EXIT_CODE -ne 0 ]; then
    echo "Failed to fetch secret from cluster (exit code: $SECRET_EXIT_CODE)"
    echo "Secret fetch output:"
    echo "$SECRET_OUTPUT"
    echo "false" > "$(workspaces.source.path)/artifact-reused"
    echo "Proceeding with build due to secret fetch failure"
    # Emit empty REUSED_IMAGE_REF to indicate no reuse
    echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
    exit 0
  fi
  
  echo "Secret fetch successful"
  echo "Secret output (first 200 chars):"
  echo "${SECRET_OUTPUT:0:200}..."
  
  # Now extract the signing key
  echo "Running: jq '.data[\"cosign.pub\"] | @base64d' -r"
  
  JQ_OUTPUT=$(echo "$SECRET_OUTPUT" | jq '.data["cosign.pub"] | @base64d' -r 2>&1)
  JQ_EXIT_CODE=$?
  
  if [ $JQ_EXIT_CODE -ne 0 ]; then
    echo "Failed to extract signing key with jq (exit code: $JQ_EXIT_CODE)"
    echo "JQ output:"
    echo "$JQ_OUTPUT"
    echo "false" > "$(workspaces.source.path)/artifact-reused"
    echo "Proceeding with build due to jq extraction failure"
    # Emit empty REUSED_IMAGE_REF to indicate no reuse
    echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
    exit 0
  fi
  
  SIGNING_KEY="$JQ_OUTPUT"
  
  if [ -z "$SIGNING_KEY" ]; then
    echo "Failed to extract signing key from cluster (empty result)"
    echo "JQ output was empty"
    echo "false" > "$(workspaces.source.path)/artifact-reused"
    echo "Proceeding with build due to signing key fetch failure"
    # Emit empty REUSED_IMAGE_REF to indicate no reuse
    echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
    exit 0
  fi
  
  # Validate that the extracted key looks like a valid public key
  if [[ ! "$SIGNING_KEY" =~ ^-----BEGIN\ PUBLIC\ KEY----- ]]; then
    echo "Failed to extract valid signing key from cluster"
    echo "Extracted key doesn't start with '-----BEGIN PUBLIC KEY-----'"
    echo "Extracted key (first 100 chars): ${SIGNING_KEY:0:100}"
    echo "false" > "$(workspaces.source.path)/artifact-reused"
    echo "Proceeding with build due to invalid signing key format"
    # Emit empty REUSED_IMAGE_REF to indicate no reuse
    echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
    exit 0
  fi

  echo "Successfully fetched signing key from cluster"
  echo "Signing key length: ${#SIGNING_KEY} characters"
  echo "Signing key first 50 chars: ${SIGNING_KEY:0:50}..."

  # Verify attestation signature using the dynamically fetched key
  echo "Verifying attestation signature for ${IMAGE%:*}:${SELECTED_CANDIDATE}..."
  
  # Create a temporary file for the signing key to avoid stdin issues
  TEMP_KEY_FILE=$(mktemp)
  echo "$SIGNING_KEY" > "$TEMP_KEY_FILE"
  echo "Using temporary key file: $TEMP_KEY_FILE"
  
  # Capture the output for debugging with a timeout to prevent hanging
  echo "Running cosign verify-attestation with timeout..."
  echo "Command: timeout 60s cosign verify-attestation --key \"$TEMP_KEY_FILE\" --insecure-ignore-tlog --type https://slsa.dev/provenance/v0.2 \"${IMAGE%:*}:${SELECTED_CANDIDATE}\""
  
  # Check if the image has attestations
  if ! cosign download attestation "${IMAGE%:*}:${SELECTED_CANDIDATE}" >/dev/null 2>&1; then
    echo "Image has no attestations, proceeding with new build"
    echo "false" > "$(workspaces.source.path)/artifact-reused"
    echo "Proceeding with build due to no attestations"
    echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
    rm -f "$TEMP_KEY_FILE"
    exit 0
  fi
  
  # Verify attestation signature
  timeout 30s cosign verify-attestation --key "$TEMP_KEY_FILE" --insecure-ignore-tlog --type https://slsa.dev/provenance/v0.2 "${IMAGE%:*}:${SELECTED_CANDIDATE}" >/dev/null 2>&1
  VERIFY_EXIT_CODE=$?
  
  # Clean up the temporary key file
  rm -f "$TEMP_KEY_FILE"
  
  if [ $VERIFY_EXIT_CODE -ne 0 ]; then
    echo "Attestation verification failed, proceeding with tree hash verification only"
    echo "true" > "$(workspaces.source.path)/artifact-reused"
    echo "Reused image reference: ${IMAGE%:*}:${SELECTED_CANDIDATE}"
    echo "${IMAGE%:*}:${SELECTED_CANDIDATE}" | tee "$(results.REUSED_IMAGE_REF.path)"
    exit 0
  fi

  # Verify tree hash in provenance
  echo "Verifying tree hash in provenance..."
  ATTESTATION_JSON=$(cosign download attestation "${IMAGE%:*}:${SELECTED_CANDIDATE}" 2>/dev/null | jq -r '.payload | @base64d | fromjson' || echo "{}")
  
  if [ -z "$ATTESTATION_JSON" ] || [ "$ATTESTATION_JSON" = "{}" ]; then
          echo "No attestation found for ${IMAGE%:*}:${SELECTED_CANDIDATE}"
      echo "false" > "$(workspaces.source.path)/artifact-reused"
      echo "Proceeding with build due to no attestation"
      # Emit empty REUSED_IMAGE_REF to indicate no reuse
      echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
  else
        # Extract all tree hashes from provenance and verify they're all the same
        PROVENANCE_TREE_HASHES=$(echo "$ATTESTATION_JSON" | jq -r '.predicate.buildConfig.tasks[] | select(.results[]?.name == "GIT_TREE_HASH") | .results[] | select(.name == "GIT_TREE_HASH") | .value // empty')
    
    if [ -z "$PROVENANCE_TREE_HASHES" ]; then
      echo "Failed to extract tree hash from provenance"
      echo "false" > "$(workspaces.source.path)/artifact-reused"
      echo "Proceeding with build due to provenance tree hash extraction failure"
      # Emit empty REUSED_IMAGE_REF to indicate no reuse
      echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
      exit 0
    fi
    
    # Check if all tree hashes are the same
    UNIQUE_HASHES=$(echo "$PROVENANCE_TREE_HASHES" | sort | uniq)
    HASH_COUNT=$(echo "$UNIQUE_HASHES" | wc -l)
    
    if [ "$HASH_COUNT" -gt 1 ]; then
      echo "ERROR: Inconsistent tree hashes found in provenance:"
      echo "$PROVENANCE_TREE_HASHES"
      echo "Unique hashes: $UNIQUE_HASHES"
      echo "false" > "$(workspaces.source.path)/artifact-reused"
      echo "Proceeding with build due to inconsistent tree hashes in provenance"
      # Emit empty REUSED_IMAGE_REF to indicate no reuse
      echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
      exit 0
    fi
    
    # Use the single unique tree hash
    PROVENANCE_TREE_HASH=$(echo "$UNIQUE_HASHES" | head -n1)
    echo "Verified all tree hashes in provenance are consistent: $PROVENANCE_TREE_HASH"
    
    if [ -z "$PROVENANCE_TREE_HASH" ]; then
      echo "Failed to extract valid tree hash from provenance"
      echo "false" > "$(workspaces.source.path)/artifact-reused"
      echo "Proceeding with build due to provenance tree hash extraction failure"
      # Emit empty REUSED_IMAGE_REF to indicate no reuse
      echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
      exit 0
    else

            
            echo "DEBUG: Tree hash comparison:"
            echo "  Provenance: '$PROVENANCE_TREE_HASH' (length: ${#PROVENANCE_TREE_HASH})"
            echo "  Calculated: '$TREE_HASH' (length: ${#TREE_HASH})"
            echo "  Comparison result: $([ "$PROVENANCE_TREE_HASH" != "$TREE_HASH" ] && echo "DIFFERENT" || echo "SAME")"
            
            if [ "$PROVENANCE_TREE_HASH" != "$TREE_HASH" ]; then
              echo "Tree hash mismatch: provenance has $PROVENANCE_TREE_HASH, calculated $TREE_HASH"
              echo "false" > "$(workspaces.source.path)/artifact-reused"
              echo "Proceeding with build due to tree hash mismatch"
              # Emit empty REUSED_IMAGE_REF to indicate no reuse
              echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
            else
        echo "Tree hash verification successful: $TREE_HASH"
        # Extract build parameters from attestation
        EXISTING_PARAMS=$(echo "$ATTESTATION_JSON" | jq -r '.predicate.invocation.parameters')
        if [ -z "$EXISTING_PARAMS" ]; then
          echo "Failed to parse attestation parameters"
          echo "false" > "$(workspaces.source.path)/artifact-reused"
          echo "Proceeding with build due to attestation parsing failure"
          # Emit empty REUSED_IMAGE_REF to indicate no reuse
          echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
        else
          echo "Extracted build parameters from existing attestation"
          # Compare current build parameters with existing ones
          CONFIG_MATCHES=true
          # Get all available parameters dynamically from environment variables
          # This will automatically include any new parameters that are added to the task
          ALL_PARAMS=()
          for env_var in $(env | grep -E '^[A-Z_]+=' | cut -d'=' -f1 | sort); do
            # Only include parameters that are likely to be task parameters
            # (exclude system environment variables and internal variables)
            if [[ "$env_var" =~ ^[A-Z_]+$ ]] && [[ ! "$env_var" =~ ^(PATH|HOME|USER|SHELL|PWD|HOSTNAME|TERM|LANG|LC_|SHLVL|LOGNAME|OLDPWD|_) ]]; then
              ALL_PARAMS+=("$env_var")
            fi
          done
          # Filter out excluded parameters
          COMPARISON_PARAMS=()
          for param in "${ALL_PARAMS[@]}"; do
            # Check if this parameter is in the exclusion list
            excluded=false
            for excluded_param in "${EXCLUSION_PARAMS[@]}"; do
              if [ "$param" = "$excluded_param" ]; then
                excluded=true
                break
              fi
            done
            if [ "$excluded" = "false" ]; then
              COMPARISON_PARAMS+=("$param")
            fi
          done
          echo "Parameters to compare: ${COMPARISON_PARAMS[*]}"
          for param in "${COMPARISON_PARAMS[@]}"; do
            # Convert UPPER_SNAKE_CASE to kebab-case for attestation lookup
            param_kebab=$(echo "$param" | tr '[:upper:]' '[:lower:]' | sed 's/_/-/g')
            # Get current parameter value dynamically
            current_value=""
            # Special handling for CONTEXT parameter mapping
            if [ "$param" = "CONTEXT" ]; then
              param_kebab="path-context"
            fi
            # Use indirect parameter expansion to get the value dynamically
            # This will work for any parameter name without needing to update the case statement
            param_value="${!param:-}"
            if [ -n "$param_value" ]; then
              current_value="$param_value"
            else
              # Try to get default value from JSON
              current_value=$(echo "$PARAM_DEFAULTS" | jq -r --arg param "$param" '.[$param] // empty')
              if [ -n "$current_value" ]; then
                echo "Parameter $param not in environment, using default value: '$current_value'"
              else
                echo "Warning: Parameter $param not found in environment and no default available, treating as empty"
                current_value=""
              fi
            fi
            # Get existing parameter value from attestation
            # Only use exact matches to prevent parameter injection attacks
            existing_value=$(echo "$EXISTING_PARAMS" | jq -r --arg param "$param" --arg param_kebab "$param_kebab" '
              # Try exact match first
              if has($param) then .[$param]
              # Try kebab-case (only for known parameter mappings)
              elif has($param_kebab) then .[$param_kebab]
              # No case-insensitive matching for security
              else empty end
            ')
            
            # If parameter exists in attestation, proceed with comparison
            if [ -n "$existing_value" ]; then
              # Compare values
              # Define array parameters that need special handling
              # This list can be easily updated when new array parameters are added
              if [[ "$param" =~ ^(BUILD_ARGS|LABELS|ANNOTATIONS)$ ]]; then
                # For array parameters, we need to sort and compare
                if [ "$current_value" != "$existing_value" ]; then
                  echo "Parameter $param mismatch: current='$current_value' vs existing='$existing_value'"
                  CONFIG_MATCHES=false
                fi
              else
                # For non-array parameters, direct comparison
                if [ "$current_value" != "$existing_value" ]; then
                  echo "Parameter $param mismatch: current='$current_value' vs existing='$existing_value'"
                  CONFIG_MATCHES=false
                fi
              fi
            else
              echo "Parameter $param not in attestation, skipping comparison"
            fi
          done
          if [ "$CONFIG_MATCHES" = "true" ]; then
            echo "All build parameters match, checking for SBOM availability..."
            
            # Check if the reused image has an SBOM attached
            if cosign download sbom "${IMAGE%:*}:${SELECTED_CANDIDATE}" >/dev/null 2>&1; then
              echo "SBOM found on reused image, verifying SBOM integrity..."
              
              # Extract SBOM blob URL from attestation
              ATTESTATION_SBOM_REF=$(echo "$ATTESTATION_JSON" | jq -r '.predicate.buildConfig.tasks[] | select(.results[]?.name == "SBOM_BLOB_URL") | .results[] | select(.name == "SBOM_BLOB_URL") | .value // empty')
              
              if [ -n "$ATTESTATION_SBOM_REF" ]; then
                echo "Found SBOM reference in attestation: $ATTESTATION_SBOM_REF"
                
                # Extract expected digest from attestation SBOM reference
                EXPECTED_SBOM_DIGEST="${ATTESTATION_SBOM_REF##*@sha256:}"
                echo "Expected SBOM digest from attestation: $EXPECTED_SBOM_DIGEST"
                
                # Download SBOM from image and calculate its digest
                if cosign download sbom "${IMAGE%:*}:${SELECTED_CANDIDATE}" > downloaded-sbom.json 2>/dev/null; then
                  ACTUAL_SBOM_DIGEST=$(sha256sum downloaded-sbom.json | cut -d' ' -f1)
                  echo "Actual SBOM digest from image: $ACTUAL_SBOM_DIGEST"
                  
                  if [ "$EXPECTED_SBOM_DIGEST" = "$ACTUAL_SBOM_DIGEST" ]; then
                    echo "✅ SBOM integrity verified: digest matches attestation"
                    echo "SBOM found on reused image, proceeding with reuse"
                    echo "true" > "$(workspaces.source.path)/artifact-reused"
                    echo "${IMAGE%:*}:${SELECTED_CANDIDATE}" > "$(workspaces.source.path)/reused-image-ref"
                    echo "${SELECTED_CANDIDATE}" > "$(workspaces.source.path)/reused-image-tag"
                    # Store the reused image reference with digest as result for downstream steps
                    echo -n "${IMAGE%:*}@${TREE_TAG_DIGEST}" | tee "$(results.REUSED_IMAGE_REF.path)"
                    echo "Reusing existing artifact with tree hash: ${TREE_HASH}"
                  else
                    echo "❌ SBOM integrity check failed: digest mismatch"
                    echo "Expected: $EXPECTED_SBOM_DIGEST"
                    echo "Actual: $ACTUAL_SBOM_DIGEST"
                    echo "SBOM may have been tampered with, proceeding with build for security compliance"
                    echo "false" > "$(workspaces.source.path)/artifact-reused"
                    # Emit empty REUSED_IMAGE_REF to indicate no reuse
                    echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
                  fi
                  
                  # Clean up downloaded SBOM
                  rm -f downloaded-sbom.json
                else
                  echo "❌ Failed to download SBOM from image for integrity verification"
                  echo "Proceeding with build for security compliance"
                  echo "false" > "$(workspaces.source.path)/artifact-reused"
                  # Emit empty REUSED_IMAGE_REF to indicate no reuse
                  echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
                fi
              else
                echo "⚠️ No SBOM reference found in attestation"
                echo "Cannot verify SBOM integrity, proceeding with build for security compliance"
                echo "false" > "$(workspaces.source.path)/artifact-reused"
                # Emit empty REUSED_IMAGE_REF to indicate no reuse
                echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
              fi
            else
              echo "No SBOM found on reused image, proceeding with build for security compliance"
              echo "false" > "$(workspaces.source.path)/artifact-reused"
              # Emit empty REUSED_IMAGE_REF to indicate no reuse
              echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
            fi
          else
            echo "Build parameters do not match, proceeding with build"
            echo "false" > "$(workspaces.source.path)/artifact-reused"
            # Emit empty REUSED_IMAGE_REF to indicate no reuse
            echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
          fi
        fi
      fi
    fi
  fi
else
  echo "No existing tree hash tag found: ${TREE_TAG}"
  echo "false" > "$(workspaces.source.path)/artifact-reused"
  echo "Proceeding with build due to no existing tree hash tag"
  # Emit empty REUSED_IMAGE_REF to indicate no reuse
  echo "" | tee "$(results.REUSED_IMAGE_REF.path)"
fi

echo "[$(date --utc -Ins)] Pre-build complete" 