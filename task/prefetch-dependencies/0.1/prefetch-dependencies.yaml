apiVersion: tekton.dev/v1
kind: Task
metadata:
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/tags: "image-build, konflux"
  name: prefetch-dependencies
spec:
  description: |-
    Task that uses Cachi2 to prefetch build dependencies.
    See docs at https://github.com/containerbuildsystem/cachi2#basic-usage.
  params:
  - description: Configures project packages that will have their dependencies prefetched.
    name: input
  - description: >
      Enable in-development package managers. WARNING: the behavior may change at any time without
      notice. Use at your own risk.
    name: dev-package-managers
    default: "false"
  - description: Set cachi2 log level (debug, info, warning, error)
    name: log-level
    default: "info"
  - name: caTrustConfigMapName
    type: string
    description: The name of the ConfigMap to read CA bundle data from.
    default: trusted-ca
  - name: caTrustConfigMapKey
    type: string
    description: The name of the key in the ConfigMap that contains the CA bundle data.
    default: ca-bundle.crt
  - name: ACTIVATION_KEY
    default: activation-key
    description: Name of secret which contains subscription activation key
    type: string

  steps:
  - name: check-prefetch-input
    image: quay.io/bcook/cachi2@sha256:cd0ee8284eb41838071e7987644fcfe05cef77f89ac426c14a2fa4ed5bd1b5ac
    # per https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting
    # the cluster will set imagePullPolicy to IfNotPresent
    env:
    - name: INPUT
      value: $(params.input)
    script: |
      if [ -z "${INPUT}" ]
      then
        # Confirm input was provided though it's likely the whole task would be skipped if it wasn't
        echo "No prefetch will be performed because no input was provided for cachi2 fetch-deps"
        exit 0
      fi

  - name: register-red-hat
    image: quay.io/bcook/cachi2@sha256:cd0ee8284eb41838071e7987644fcfe05cef77f89ac426c14a2fa4ed5bd1b5ac
    env:
    - name: INPUT
      value: $(params.input)
    - name: ACTIVATION_KEY
      value: $(params.ACTIVATION_KEY)
    volumeMounts:
    - mountPath: /shared
      name: shared
    - mountPath: /activation-key
      name: activation-key
    results:
    - name: registered
      type: string
    script: |
      #!/bin/bash
      echo "false" > /shared/registered
      ACTIVATION_KEY_PATH="/activation-key"

      REGISTERED="false"
      if [ -e /activation-key/org ]; then
        cp -r --preserve=mode "$ACTIVATION_KEY_PATH" /tmp/activation-key
        mkdir /shared/rhsm-tmp
        VOLUME_MOUNTS+=(--volume /tmp/activation-key:/activation-key -v /shared/rhsm-tmp:/etc/pki/entitlement:Z)

        echo "Registering with Red Hat subscription manager."
        subscription-manager register --org "$(cat /tmp/activation-key/org)" --activationkey "$(cat /tmp/activation-key/activationkey)"
        REGISTERED=$?
        # copy generated certificates to /shared/rhsm-tmp
        cp /etc/pki/entitlement/*.pem /shared/rhsm-tmp
        echo "true" > /shared/registered

      else
        echo "false" > /shared/registered
      fi

  - name: preprocess-input
    image: quay.io/bcook/cachi2@sha256:cd0ee8284eb41838071e7987644fcfe05cef77f89ac426c14a2fa4ed5bd1b5ac
    # per https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting
    # the cluster will set imagePullPolicy to IfNotPresent

    env:
    - name: INPUT
      value: $(params.input)
    - name: ACTIVATION_KEY
      value: $(params.ACTIVATION_KEY)
    volumeMounts:
    - mountPath: /shared
      name: shared
    script: |
      #!/bin/python3
      import json
      import os
      import sys

      def string_to_json(input: str):
          if input in ["gomod", "pip", "npm", "yarn", "bundler", "rpm"]:
              input = '{"type": "%s"}' % input
              print("json: %s" % input)
          return input


      def json_to_list(input: str):
          input = json.loads(input)
          if type(input) is dict:
              input = [input]
          return json.dumps(input)


      def inject_certs(input: str):
          input = json.loads(input)
          if type(input is list):
              cert = os.getenv("RHT_CERT", None)
              key = os.getenv("RHT_KEY", None)
              ca_bundle = os.getenv("CA_BUNDLE", None)

              for pkg_man in input:
                  if pkg_man["type"] == "rpm":

                      # preserve verify setting
                      verify = \
                          pkg_man.get("options", {}).get("ssl", {}).get("verify", 1)

                      # preserve other options
                      options = pkg_man.get('options', {})

                      ssl_options = {
                          "client_key": key,
                          "client_cert": cert,
                          "ca_bundle": ca_bundle,
                          "verify": verify}

                      options['ssl'] = ssl_options
                      pkg_man["options"] = options
              return (json.dumps(input))

          else:
              # throw an error
              print("boooo!")


      def convert_input(input):
          input = string_to_json(input)
          input = json_to_list(input)
          input = inject_certs(input)
          return input


      if __name__ == '__main__':
        f = open("/shared/registered", "r")
        registered = f.read()
        if registered == "false":
            print("System is not registered. Skipping.")
            sys.exit()

        elif registered == "true":
            input = sys.argv[1]
            input = convert_input(input)
            print(input)
        else:
            print("unexpected result for 'registered'.")
            sys.exit(1)

  - name: prefetch-dependencies
    image: quay.io/bcook/cachi2@sha256:cd0ee8284eb41838071e7987644fcfe05cef77f89ac426c14a2fa4ed5bd1b5ac
    # per https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting
    # the cluster will set imagePullPolicy to IfNotPresent
    env:
    - name: INPUT
      value: $(params.input)
    - name: DEV_PACKAGE_MANAGERS
      value: $(params.dev-package-managers)
    - name: LOG_LEVEL
      value: $(params.log-level)
    - name: WORKSPACE_GIT_AUTH_BOUND
      value: $(workspaces.git-basic-auth.bound)
    - name: WORKSPACE_GIT_AUTH_PATH
      value: $(workspaces.git-basic-auth.path)
    - name: WORKSPACE_NETRC_BOUND
      value: $(workspaces.netrc.bound)
    - name: WORKSPACE_NETRC_PATH
      value: $(workspaces.netrc.path)
    volumeMounts:
      - name: trusted-ca
        mountPath: /mnt/trusted-ca
        readOnly: true
      - mountPath: /activation-key
        name: activation-key
      - mountPath: /shared
        name: shared
    script: |
      if [ "$DEV_PACKAGE_MANAGERS" = "true" ]; then
        dev_pacman_flag=--dev-package-managers
      else
        dev_pacman_flag=""
      fi

      # Copied from https://github.com/konflux-ci/build-definitions/blob/main/task/git-clone/0.1/git-clone.yaml
      if [ "${WORKSPACE_GIT_AUTH_BOUND}" = "true" ] ; then
        if [ -f "${WORKSPACE_GIT_AUTH_PATH}/.git-credentials" ] && [ -f "${WORKSPACE_GIT_AUTH_PATH}/.gitconfig" ]; then
          cp "${WORKSPACE_GIT_AUTH_PATH}/.git-credentials" "${HOME}/.git-credentials"
          cp "${WORKSPACE_GIT_AUTH_PATH}/.gitconfig" "${HOME}/.gitconfig"
        # Compatibility with kubernetes.io/basic-auth secrets
        elif [ -f "${WORKSPACE_GIT_AUTH_PATH}/username" ] && [ -f "${WORKSPACE_GIT_AUTH_PATH}/password" ]; then
          HOSTNAME=$(cd "$(workspaces.source.path)/source" && git remote get-url origin | awk -F/ '{print $3}')
          echo "https://$(cat ${WORKSPACE_GIT_AUTH_PATH}/username):$(cat ${WORKSPACE_GIT_AUTH_PATH}/password)@$HOSTNAME" > "${HOME}/.git-credentials"
          echo -e "[credential \"https://$HOSTNAME\"]\n  helper = store" > "${HOME}/.gitconfig"
        else
          echo "Unknown git-basic-auth workspace format"
          exit 1
        fi
        chmod 400 "${HOME}/.git-credentials"
        chmod 400 "${HOME}/.gitconfig"
      fi

      if [ "${WORKSPACE_NETRC_BOUND}" = "true" ]; then
        cp "${WORKSPACE_NETRC_PATH}/.netrc" "${HOME}/.netrc"
      fi

      ca_bundle=/mnt/trusted-ca/ca-bundle.crt
      if [ -f "$ca_bundle" ]; then
        echo "INFO: Using mounted CA bundle: $ca_bundle"
        cp -vf $ca_bundle /etc/pki/ca-trust/source/anchors
        update-ca-trust
      fi

      ACTIVATION_KEY_PATH="/activation-key"
      if [ -d "$ACTIVATION_KEY_PATH" ]; then
          echo "Detected activation key, registering with RHSM."
        
          # todo: make sure orgid key is consistent with buildah task and docs
          subscription-manager register \
            --org $(cat "/activation-key/orgid") \
            --activationkey $(cat "/activation-key/activationkey")

          # detect entitlement certs and setup environment variables
          ls /etc/pki/entitlement/

          export RHSM_ID=$(ls /etc/pki/entitlement/ | grep key | cut -d - -f 1)
          echo $RHSM_ID
          export C2_CLIENT_CERT="/etc/pki/entitlement/$RHSM_ID.pem"
          export C2_CLIENT_KEY="/etc/pki/entitlement/$RHSM_ID-key.pem"
          echo "Using client certificate $C2_CLIENT_CERT and key $C2_CLIENT_KEY."
        fi

      cachi2 --log-level="$LOG_LEVEL" fetch-deps \
      $dev_pacman_flag \
      --source=$(workspaces.source.path)/source \
      --output=$(workspaces.source.path)/cachi2/output \
      "${INPUT}"

      cachi2 --log-level="$LOG_LEVEL" generate-env $(workspaces.source.path)/cachi2/output \
      --format env \
      --for-output-dir=/cachi2/output \
      --output $(workspaces.source.path)/cachi2/cachi2.env

      cachi2 --log-level="$LOG_LEVEL" inject-files $(workspaces.source.path)/cachi2/output \
      --for-output-dir=/cachi2/output
  workspaces:
  - name: source
    description: Workspace with the source code, cachi2 artifacts will be stored on the workspace as well
  - name: git-basic-auth
    description: |
      A Workspace containing a .gitconfig and .git-credentials file or username and password.
      These will be copied to the user's home before any cachi2 commands are run. Any
      other files in this Workspace are ignored. It is strongly recommended
      to bind a Secret to this Workspace over other volume types.
    optional: true
  - name: netrc
    description: |
      Workspace containing a .netrc file. Cachi2 will use the credentials in this file when
      performing http(s) requests.
    optional: true
  volumes:
    - name: shared
      emptyDir: {}
    - name: etc-pki-entitlement
      emptyDir: {}
    - name: activation-key
      secret:
        optional: true
        secretName: $(params.ACTIVATION_KEY)
    - name: trusted-ca
      configMap:
        name: $(params.caTrustConfigMapName)
        items:
          - key: $(params.caTrustConfigMapKey)
            path: ca-bundle.crt
        optional: true
